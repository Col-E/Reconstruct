package me.darknet.resconstruct;

import me.coley.analysis.SimAnalyzer;
import me.coley.analysis.SimInterpreter;
import me.coley.analysis.TypeChecker;
import me.coley.analysis.TypeResolver;
import me.coley.analysis.util.InheritanceGraph;
import me.coley.analysis.util.TypeUtil;
import me.darknet.resconstruct.analysis.StackCopyingSimAnalyser;
import me.darknet.resconstruct.solvers.InstructionsSolver;
import me.darknet.resconstruct.util.InheritanceUtils;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FrameNode;

import java.util.HashMap;
import java.util.Map;
import java.util.NavigableMap;

public class Reconstruct {
	private final Map<String, ClassReader> inputs = new HashMap<>();
	private ClassHierarchy hierarchy;
	private InheritanceGraph graph;
	private boolean ignoreSolveExceptions;


	/**
	 * New instance.
	 */
	public Reconstruct() {
		reset();
	}

	/**
	 * If solve exceptions are ignored, one class's bytecode that cannot be analyzed will not prevent other classes
	 * from being analyzed for phantom generation processing.
	 *
	 * @param ignoreSolveExceptions
	 * 		Flag to ignore solve exceptions.
	 */
	public void setIgnoreSolveExceptions(boolean ignoreSolveExceptions) {
		this.ignoreSolveExceptions = ignoreSolveExceptions;
	}

	/**
	 * Adds a class to the input.
	 * Each input will be scanned for references, of which will be analyzed in {@link #run()}.
	 *
	 * @param classFile
	 * 		Class bytecode.
	 */
	public void add(byte[] classFile) {
		ClassReader cr = new ClassReader(classFile);
		inputs.put(cr.getClassName(), cr);
		hierarchy.createInputPhantom(cr);
		graph.addClass(classFile);
	}

	/**
	 * Clear input information.
	 */
	public void reset() {
		hierarchy = new ClassHierarchy();
		graph = InheritanceUtils.getClasspathGraph().copy();
		inputs.clear();
	}

	/**
	 * Read input and generate phantom classes.
	 */
	public void run() {
		// Initial pass to generate base phantom types
		for (ClassReader cr : inputs.values())
			cr.accept(new PhantomVisitor(Opcodes.ASM9, null, this), ClassReader.SKIP_FRAMES);
		// Second pass to flesh out phantom types
		for (ClassReader cr : inputs.values()) {
			ClassNode classNode = new ClassNode();
			cr.accept(classNode, ClassReader.EXPAND_FRAMES);
			InstructionsSolver solver = new InstructionsSolver(this);
			try {
				solver.solve(hierarchy, classNode);
			} catch (SolveException ex) {
				if (!ignoreSolveExceptions)
					throw ex;
			}
		}
	}

	/**
	 * Binary export of {@link #getHierarchy()}.
	 *
	 * @return Map of class names, to generated bytecode.
	 */
	public Map<String, byte[]> build() {
		return hierarchy.export();
	}

	/**
	 * <b>Note:</b> Each method should be given its own analyzer instance.
	 *
	 * @return New analyzer instance.
	 */
	public SimAnalyzer newAnalyzer(NavigableMap<Integer, FrameNode> stackFrames) {
		SimInterpreter interpreter = new SimInterpreter();
		SimAnalyzer analyzer = new StackCopyingSimAnalyser(stackFrames, interpreter) {
			@Override
			public TypeChecker createTypeChecker() {
				return (parent, child) -> graph.getAllParents(child.getInternalName())
						.contains(parent.getInternalName());
			}

			@Override
			public TypeResolver createTypeResolver() {
				return new TypeResolver() {
					@Override
					public Type common(Type type1, Type type2) {
						String common = graph.getCommon(type1.getInternalName(), type2.getInternalName());
						if (common != null)
							return Type.getObjectType(common);
						return TypeUtil.OBJECT_TYPE;
					}

					@Override
					public Type commonException(Type type1, Type type2) {
						String common = graph.getCommon(type1.getInternalName(), type2.getInternalName());
						if (common != null)
							return Type.getObjectType(common);
						return TypeUtil.EXCEPTION_TYPE;
					}
				};
			}
		};
		analyzer.setThrowUnresolvedAnalyzerErrors(false);
		return analyzer;
	}

	/**
	 * @return Output class hierarchy.
	 */
	public ClassHierarchy getHierarchy() {
		return hierarchy;
	}

	/**
	 * @return Inheritance information for classes.
	 */
	public InheritanceGraph getGraph() {
		return graph;
	}

	/**
	 * @return Map of inputs classes.
	 */
	public Map<String, ClassReader> getInputs() {
		return inputs;
	}
}
